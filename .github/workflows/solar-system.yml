name: Solar System Workflow

on:
    workflow_dispatch:
    push:
        branches:
            - main
            - 'feature/*'
#workflow fails at testing job due to unestablishment of MongoDB connection if these value are not passed.
env:      #These credentials belong to prod database and its going to impact the performance of of the prod db. Its never recommended to use prod db for testing the app. Instead, use dedicated db for testing.
    MONGO_URI: 'mongodb+srv://supercluster.d83jj.mongodb.net/superData'
    MONGO_USERNAME: ${{ vars.MONGO_USERNAME }}
    MONGO_PASSWORD: ${{ secrets.MONGO_PASSWORD }}

jobs:
    unit-testing:              #Example of utilizing service container with job steps running in hosted runner
        name: Unit Testing
        services:
          mongo-db:
            image: siddharth67/mongo-db:non-prod   #non prod db
            ports:
              - 27017:27017   #port mapping between local host and service container
        env:    #env variables defined at job level takes precedence over the env variable defined at workflo level
          MONGO_URI: 'mongodb://localhost:27017/superData'
          MONGO_USERNAME: non-prod-user
          MONGO_PASSWORD: non-prod-password ## for demo purpose, the credentials are hardcoded
        strategy:
            matrix:
                nodejs_version: [18, 20]
                operating_system: [ubuntu-latest]
                exclude:
                    - nodejs_version: 18
                      operating_system: macos-latest
        runs-on: ${{ matrix.operating_system }}
        steps:
            - name: Checkout Repository
              uses: actions/checkout@v4
            
            - name: Setup NodeJS Version - ${{ matrix.nodejs_version }}
              uses: actions/setup-node@v3
              with:
                node-version: ${{ matrix.nodejs_version }}

            - name: Cache NPM Dependencies
              uses: actions/cache@v3
              with:
                path: node_modules
                key: ${{ runner.os }}-node-modules-${{ hashFiles('package-lock.json') }}

            - name: Install Dependencies
              run: npm install

            - name: Unit Testing
              id: node-unit-testing-step    
              run: npm test
            #If the above Unit Testing step fails(for example, failed test case or syntax error), the Archive Test Result step will be skipped. 
            #And you cannot debug the issue without seeing the test results but is is not available since this setp will be skipped in a failure scenario.
            #To overcome that, we can use expressions to to run Archive Test Result step always irrespective of above step's state
            - name: Archive Test Result
              #In case of conditionif: steps.node-unit-testing-step.outcome == 'failure' || steps.node-unit-testing-step.outcome == 'success'
              #Although, this condition is true, this steps will still be skipped in case of failure. Its beacause, a deafult status check of success() is applied unles you include other functions.
              # So, the below condition will be success() && (steps.node-unit-testing-step.outcome == 'failure' || steps.node-unit-testing-step.outcome == 'success'). The condition will be false when the previous step is failed. Hence the step will be skipped.
              #Conditionif: failure() && (steps.node-unit-testing-step.outcome == 'failure' || steps.node-unit-testing-step.outcome == 'success') will only run his step in case of failure and in success scenario, this step will be skipped.
              if: always() #runs irrespective of the ststus of previous step
              uses: actions/upload-artifact@v3
              with:
                name: Mocha-Test-Result
                path: test-results.xml

    #Need to setup nodejs first since its a different job  ##runs in parallel with unit-testing job
    code-coverage:       #Example of utilizing job container(for running steps) and service container
        name: Code-Coverage
        container:
          image: node:18
        services:
          mongo-db:
            image: siddharth67/mongo-db:non-prod   #non prod db
            options:
              --name mongo  #job container name label
        env:    #env variables defined at job level takes precedence over the env variable defined at workflo level
          MONGO_URI: 'mongodb://mongo:27017/superData'  #'mongo' name is how we refer to the service container
          MONGO_USERNAME: non-prod-user
          MONGO_PASSWORD: non-prod-password ## for demo purpose, the credentials are hardcoded
        runs-on: ubuntu-latest
        steps:
            - name: Checkout Repository
              uses: actions/checkout@v4
            
            # - name: Setup NodeJS Version - 18   #As we are using job container, we don't need this step to setup NodeJS
            #   uses: actions/setup-node@v3
            #   with:
            #     node-version: 18

            - name: Cache NPM Dependencies
              uses: actions/cache@v3
              with:
                path: node_modules
                key: ${{ runner.os }}-node-modules-${{ hashFiles('package-lock.json') }}

            - name: Install Dependencies
              run: npm install

            - name: Check Code Coverage
              continue-on-error: true   #We want this job to be run even if the coverage is below the threshold
              run: npm run coverage

            - name: Archive Test Result
              uses: actions/upload-artifact@v4
              with:
                name: Code-Coverage-Result
                path: coverage
                retention-days: 5
                
    Docker:
      name: Containerization
      services:
        mongo-db:
          image: siddharth67/mongo-db:non-prod   #non prod db
          ports:
            - 27017:27017   #port mapping between local host and service container
      env:    #env variables defined at job level takes precedence over the env variable defined at workflo level
        MONGO_URI: 'mongodb://localhost:27017/superData'
        MONGO_USERNAME: non-prod-user
        MONGO_PASSWORD: non-prod-password
      permissions:          #permissions added to write packages to github token
        packages: write
      runs-on: ubuntu-latest
      needs: [unit-testing, code-coverage] #this job should run only after unit testing and code coverage
      steps:
        - name: Checkout Repository
          uses: actions/checkout@v4

        - name: Dockerhub Login
          uses: docker/login-action@v2.2.0
          with:
            username: ${{ vars.DOCKERHUB_USERNAME }}
            password: ${{ secrets.DOCKERHUB_PASSWORD }}

        - name: GHCR Login
          uses: docker/login-action@v2.2.0
          with:
            registry: ghcr.io
            username: ${{ github.repository_owner }}   #context attribute
            password: ${{ secrets.GITHUB_TOKEN }}      #A github token is created at the start of each workflow and we can use that token to authenticate and by default it has only read access

        - name: Docker Build for testing
          uses: docker/build-push-action@v5
          with:
            context: .   # path of dockerfile in the repo
            push: false  # not pushing the image in this step
            tags: ${{ vars.DOCKERHUB_USERNAME }}/solar-system:${{ github.sha }}  #SHA value of the commit id in github
        
        - name: Docker Image Testing
          run: |
            docker images
            docker run --name solar-system-app -d \
            -p 3000:3000 \
            -e MONGO_URI=$MONGO_URI \
            -e MONGO_USERNAME=$MONGO_USERNAME \
            -e MONGO_PASSWORD=$MONGO_PASSWORD \
            ${{ vars.DOCKERHUB_USERNAME }}/solar-system:${{ github.sha }}

            export IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' solar-system-app)
            echo $IP 

            echo Testing Image URL using wget
            wget -q -O - 127.0.0.1:3000/live | grep live
          #We are not using docker container's IP to test here. Instead, we are using local host with live endpoint defined in app.js
        
        - name: Container Registry Push
          uses: docker/build-push-action@v4
          with:
            context: .
            push: true
            tags: |                         #multiple tags for pushing image to multiple registries
              ${{ vars.DOCKERHUB_USERNAME }}/solar-system:${{ github.sha }}
              ghcr.io/${{ github.repository_owner }}/solar-system:${{ github.sha }}

    Dev-Deploy:
      needs: Docker
      outputs:
        APP_INGRESS_URL: ${{ steps.set-ingress-host-address.outputs.APP_INGRESS_HOST }}  #OUTPUT variable mapping for Ingress URL
      runs-on: ubuntu-latest
      steps:
        - name: Checkout Repo
          uses: actions/checkout@v4
        
        # For K8s on Azure
        # - name: Install kubectl CLI
        #   uses: azure/setup-kubectl@v3
        #   with:
        #     version: 'v1.26.0'

        # - name: Setup Kubeconfig file
        #   uses: azure/k8s-set-context@v3
        #   with:
        #     method: kubeconfig
        #     kubeconfig: <secret kubeconfig variable>  #The kubeconfig fie has to be stored in repository secrets

        # For K8s on GKE
        - name: Setup gcloud CLI
          uses: 'google-github-actions/auth@v2'
          with:
            credentials_json: ${{ secrets.GCP_SA_KEY }}
    
        - id: 'get-credentials'
          uses: 'google-github-actions/get-gke-credentials@v2'
          with:
            cluster_name: autopilot-cluster-1
            project_id: diesel-harmony-416707
            location: us-central1

        - name: Fetch Kubernetes Cluster Details
          run: |
            kubectl version
            echo -----------------------------------------------
            kubectl get nodes

        - name: Save Nginx Ingress controller IP as GITHUB Environment variable
          run: |
            echo "INGRESS_IP=34.160.218.146" >> $GITHUB_ENV 
          # for demo purpose, this value is hardcoded. Otherwise,
          # echo "INGRESS_IP=$(kubectl -n ingress-nginx get services ingress-nginx-controller -o jsonpath="{.status.loadBalancer.ingress[0].ip}")" >> $GITHUB_ENV
          # The values is stored in INGRESS_IP env variable and this can be used across all jobs or steps in a workflow
            
        - name: Replace Tokens in Manifests file
          uses: cschleiden/replace-tokens@v1
          with:
            tokenPrefix: '_{_'  #Manifest files has some varibles like _{_NAMESPACE_}_. 
            tokenSuffix: '_}_'
            files: '["kubernetes/development/*.yaml"]'   #Manifests file relative path and it finds these variables in those files with this prefix and suffix
          env:   #List the variables to replace with the values listed below
            NAMESPACE: ${{ vars.NAMESPACE }}
            REPLICAS: ${{ vars.REPLICAS }}
            IMAGE: ${{ vars.DOCKERHUB_USERNAME }}/solar-system:${{ github.sha }}
            INGRESS_IP: ${{ env.INGRESS_IP }}

        - name: Check files to varify variables replacement
          run: |
            cat kubernetes/development/*.yaml

        - name: Create MongoDB Secret  #we have to pass the credentials by creatinh k8s secret
          run: |
            kubectl -n ${{ vars.NAMESPACE }} create secret generic mongo-db-creds \
            --from-literal=MONGO_URI=${{ env.MONGO_URI }} \
            --from-literal=MONGO_USERNAME=${{ vars.MONGO_USERNAME }} \
            --from-literal=MONGO_PASSWORD=${{ secrets.MONGO_PASSWORD }} \
            --save-config \
            --dry-run=client \
            -o yaml | kubectl apply -f -

        - name: Deploy to dev env
          run: kubectl apply -f kubernetes/development

        - name: Set App Ingress Host URL   #For storing the INGRESS URL to use it in the next job
          id: set-ingress-host-address
          run: |
            echo "APP_INGRESS_HOST=$(kubectl -n ${{ vars.NAMESPACE }} get ingress -o jsonpath="{.items[0].status.loadBalancer.ingress[0].ip}")" >> "$GITHUB_OUTPUT"  
          # echo "APP_INGRESS_HOST=$(kubectl -n ${{ vars.NAMESPACE }} get ingress -o jsonpath="{.items[0].spec.tls[0].hosts[0]}")" >> $GITHUB_OUTPUT"  #This is for different ingress implementation

    integration-testing:
      name: Dev Integration Testing
      needs: Dev-Deploy
      runs-on: ubuntu-latest
      steps:
        - name: Test URL Output using CURL and JQ
          env:
            URL: ${{ needs.Dev-Deploy.outputs.APP_INGRESS_URL}}  #using outpute stored in previous job; Instead of actual URL, we are using IP address
          run: |
            echo "$URL" 
            echo "-------------------------------------------------"
            curl http://$URL/live -s -k | jq -r .status | grep -i live


